문제를 보자마자 DP를 생각했고 간단하게 접근할 수 있었다.
문제에서 
  0 - 자유롭게 이동
  1 - 통행금지
  2 - 직직만 가능
이렇게 설명하고 있다. 이것을 보고
  어떠한 좌표로 들어올때에 어떤 방향으로 들어왔는지를 기억해야한다고 생각했다.
  따라서 DP를 사용할 변수 설정 int car[555][555][2] = { 0, };   //좌표 + 그 좌표로 들어온 방향 0=오른쪽, 1=아래
car[x][y][0]=k 일때 x,y 좌표에 오른쪽 방향으로 들어온 차들의 개수는 k 개이다
를 의미한다.
  따라서 어떠한 좌표에 도달할 수 있는 방법은 위에서들어오거나 왼쪽에서 들어오거나 두가지이고
  이때 왼쪽이나 위쪽에 2로 설정되어있는지 확인한다
  2라면, 방향을 체크해주고 더해줘야하기때문
  0이라면, 방향상관없이 모두 더해주고
  1이라면 무시
코드를 작성하고 제출했지만 fail을 받았고 계속해서 아무리 생각해도 맞는것같고 테스트케이스를 계속해서 대입해도 문제가 없었다.
하지만 문제 초기에 적혀있던 말이 생각났다.
  전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.
코드를 작성하다보니 무시해서 작성하게되었고 초기화 코드를 작성해주니 통과하게되었다....
  좀 문제가 하라는 대로 진행해라!
  전역변수에 설정해주어도 0으로 초기화 되는 것을 알기에 저 말을 왜 적어놓았는지가 궁금해졌다.
  알아보니
  제가 알기로는, 위와 같이 전역 변수를 반드시 초기화 해달라는 이야기가 있다는 것은, 내부 채점 시스템에서 여러개의 케이스를 한번에 채점을 한다는 것으로 알고 있습니다.
  그렇기 때문에 각 테스트케이스들이 서로에게 영향을 미치지 않게 하기 위해서 초기화를 해줘야 하는 것으로 알고 있습니다.
이런 의미였다.

  #include <vector>
#include <iostream>

using namespace std;

int MOD = 20170805;
long long car[555][555][2] = { 0, };   //좌표 + 그 좌표로 들어온 방향 0=오른쪽, 1=아래
// 전역 변수를 정의할 경우 함수 내에 초기화 코드를 꼭 작성해주세요.
int solution(int m, int n, vector<vector<int>> city_map) {
    for (int i = 0; i < 555; i++) {
        for (int j = 0; j < 555; j++) {
            car[i][j][0] = 0;
            car[i][j][1] = 0;
        }
    }
    //초기화 구문 추가
    for (int i = 0; i < m; i++) {
        if (city_map[i][0] == 1)
            break;
        car[i][0][1] = 1;
    }
    for (int i = 0; i < n; i++) {
        if (city_map[0][i] == 1)
            break;
        car[0][i][0] = 1;
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            //위쪽 칸 탐색
            if (city_map[i - 1][j] == 0) {    //위쪽칸이 0일때
                car[i][j][1] += (car[i - 1][j][0] + car[i - 1][j][1]) % MOD;
            }
            else if (city_map[i - 1][j] == 2) {    //위쪽칸이 2일때
                car[i][j][1] += car[i - 1][j][1] % MOD;
            }
            //왼쪽 칸 탐색
            if (city_map[i][j - 1] == 0) {    //왼쪽칸이 0일때
                car[i][j][0] += (car[i][j - 1][0] + car[i][j - 1][1]) % MOD;
            }
            else if (city_map[i][j - 1] == 2) {    //왼쪽칸이 2일때
                car[i][j][0] += car[i][j - 1][0] % MOD;
            }

        }
    }
    return (car[m - 1][n - 1][0] + car[m - 1][n - 1][1]) % MOD;
}
